diff --git a/enc/trans/single_byte.trans b/enc/trans/single_byte.trans
index 1bf1001..7c07854 100644
--- a/enc/trans/single_byte.trans
+++ b/enc/trans/single_byte.trans
@@ -2,11 +2,12 @@
 
 <%
   us_ascii_map = [["{00-7f}", :nomap]]
+  binary_map   = [["{00-ff}", :nomap]]
 
   transcode_tblgen "US-ASCII", "UTF-8", us_ascii_map
   transcode_tblgen "UTF-8", "US-ASCII", us_ascii_map
-  transcode_tblgen "ASCII-8BIT", "UTF-8", us_ascii_map
-  transcode_tblgen "UTF-8", "ASCII-8BIT", us_ascii_map
+  transcode_tblgen "ASCII-8BIT", "UTF-8", binary_map
+  transcode_tblgen "UTF-8", "ASCII-8BIT", binary_map, '{00-ff}'
 
   CONTROL1_TO_UCS_TBL = (0x80..0x9f).map {|c| ["%02X" % c, c] }
 
diff --git a/encoding.c b/encoding.c
index b8c5f6d..60fa97e 100644
--- a/encoding.c
+++ b/encoding.c
@@ -806,6 +806,12 @@ rb_enc_compatible(VALUE str1, VALUE str2)
 	    if (cr2 == ENC_CODERANGE_7BIT) {
 		return enc1;
 	    }
+	    if (idx1 == ENCINDEX_UTF_8 && idx2 == ENCINDEX_ASCII) {
+		return enc2;
+	    }
+	    else if (idx1 == ENCINDEX_ASCII && idx2 == ENCINDEX_UTF_8) {
+		return enc1;
+	    }
 	}
 	if (cr1 == ENC_CODERANGE_7BIT)
 	    return enc2;
@@ -901,6 +907,11 @@ rb_enc_codepoint_len(const char *p, const char *e, int *len_p, rb_encoding *enc)
 	if (len_p) *len_p = MBCLEN_CHARFOUND_LEN(r);
         return rb_enc_mbc_to_codepoint(p, e, enc);
     }
+    else if (enc == rb_utf8_encoding() && MBCLEN_CHARFOUND_P(r = rb_enc_precise_mbclen(p, e, rb_ascii8bit_encoding()))) {
+	// swallow invalid byte sequence in utf-8 strings; treat as ascii-8bit instead
+	if (len_p) *len_p = MBCLEN_CHARFOUND_LEN(r);
+        return rb_enc_mbc_to_codepoint(p, e, rb_ascii8bit_encoding());
+    }
     else
 	rb_raise(rb_eArgError, "invalid byte sequence in %s", rb_enc_name(enc));
 }
diff --git a/re.c b/re.c
index 9fdbf54..661909c 100644
--- a/re.c
+++ b/re.c
@@ -1235,15 +1235,15 @@ static rb_encoding*
 rb_reg_prepare_enc(VALUE re, VALUE str, int warn)
 {
     rb_encoding *enc = 0;
+    enc = rb_enc_get(str);
 
-    if (rb_enc_str_coderange(str) == ENC_CODERANGE_BROKEN) {
+    if (rb_enc_str_coderange(str) == ENC_CODERANGE_BROKEN && enc != rb_utf8_encoding()) {
         rb_raise(rb_eArgError,
             "invalid byte sequence in %s",
             rb_enc_name(rb_enc_get(str)));
     }
 
     rb_reg_check(re);
-    enc = rb_enc_get(str);
     if (!rb_enc_str_asciicompat_p(str)) {
         if (RREGEXP(re)->ptr->enc != enc) {
 	    reg_enc_error(re, str);
@@ -1253,12 +1253,17 @@ rb_reg_prepare_enc(VALUE re, VALUE str, int warn)
         if (RREGEXP(re)->ptr->enc != enc &&
 	    (!rb_enc_asciicompat(RREGEXP(re)->ptr->enc) ||
 	     rb_enc_str_coderange(str) != ENC_CODERANGE_7BIT)) {
+            if ((RREGEXP(re)->ptr->enc == rb_ascii8bit_encoding() && enc == rb_utf8_encoding()) ||
+                (enc == rb_ascii8bit_encoding() && RREGEXP(re)->ptr->enc == rb_utf8_encoding())) {
+                return rb_ascii8bit_encoding();
+            }
 	    reg_enc_error(re, str);
 	}
 	enc = RREGEXP(re)->ptr->enc;
     }
     if (warn && (RBASIC(re)->flags & REG_ENCODING_NONE) &&
 	enc != rb_ascii8bit_encoding() &&
+	enc != rb_utf8_encoding() && // rack-1.4.1/lib/rack/utils.rb:87: warning: regexp match /.../n against to UTF-8 string
 	rb_enc_str_coderange(str) != ENC_CODERANGE_7BIT) {
 	rb_warn("regexp match /.../n against to %s string",
 		rb_enc_name(enc));
diff --git a/string.c b/string.c
index 134d65b..c721c7f 100644
--- a/string.c
+++ b/string.c
@@ -1947,7 +1947,11 @@ rb_enc_cr_str_buf_cat(VALUE str, const char *ptr, long len,
     if (ptr_cr_ret)
         *ptr_cr_ret = ptr_cr;
 
-    if (str_encindex != ptr_encindex &&
+    if ((str_encindex == rb_utf8_encindex() && ptr_encindex == rb_ascii8bit_encindex()) ||
+        (str_encindex == rb_ascii8bit_encindex() && ptr_encindex == rb_utf8_encindex())) {
+        /* fall through to conditional below */
+    }
+    else if (str_encindex != ptr_encindex &&
         str_cr != ENC_CODERANGE_7BIT &&
         ptr_cr != ENC_CODERANGE_7BIT) {
       incompatible:
@@ -1956,7 +1960,13 @@ rb_enc_cr_str_buf_cat(VALUE str, const char *ptr, long len,
             rb_enc_name(rb_enc_from_index(ptr_encindex)));
     }
 
-    if (str_cr == ENC_CODERANGE_UNKNOWN) {
+    if (str_encindex != ptr_encindex &&
+        str_cr != ENC_CODERANGE_7BIT &&
+        ptr_cr != ENC_CODERANGE_7BIT) {
+        res_encindex = rb_ascii8bit_encindex();
+        res_cr = ENC_CODERANGE_VALID;
+    }
+    else if (str_cr == ENC_CODERANGE_UNKNOWN) {
         res_encindex = str_encindex;
         res_cr = ENC_CODERANGE_UNKNOWN;
     }
@@ -2227,6 +2237,10 @@ rb_str_comparable(VALUE str1, VALUE str2)
 	if (rb_enc_asciicompat(rb_enc_from_index(idx1)))
 	    return TRUE;
     }
+    if ((idx1 == rb_utf8_encindex() && idx2 == rb_ascii8bit_encindex()) ||
+        (idx1 == rb_ascii8bit_encindex() && idx2 == rb_utf8_encindex())) {
+        return TRUE;
+    }
     return FALSE;
 }
 
@@ -5882,7 +5896,7 @@ rb_str_split_m(int argc, VALUE *argv, VALUE str)
 	char *sptr = RSTRING_PTR(spat);
 	long slen = RSTRING_LEN(spat);
 
-	if (is_broken_string(str)) {
+	if (is_broken_string(str) && STR_ENC_GET(str) != rb_utf8_encoding()) {
 	    rb_raise(rb_eArgError, "invalid byte sequence in %s", rb_enc_name(STR_ENC_GET(str)));
 	}
 	if (is_broken_string(spat)) {

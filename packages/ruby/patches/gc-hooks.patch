diff --git a/gc.c b/gc.c
index 4bfa65d..6daf165 100644
--- a/source/gc.c
+++ b/source/gc.c
@@ -192,6 +192,67 @@ static void run_final();
 static VALUE nomem_error;
 static void garbage_collect();
 
+typedef struct gc_event_hook {
+    rb_gc_event_hook_func_t func;
+    rb_gc_event_t events;
+    struct gc_event_hook *next;
+} rb_gc_event_hook_t;
+
+static rb_gc_event_hook_t *gc_event_hooks;
+
+#define EXEC_GC_EVENT_HOOK(event, obj) \
+    do { \
+ rb_gc_event_hook_t *hook = gc_event_hooks; \
+        rb_gc_event_hook_func_t hook_func; \
+        rb_gc_event_t events; \
+ \
+ while (hook) { \
+            hook_func = hook->func; \
+            events = hook->events; \
+            hook = hook->next; \
+     if (events & event) \
+   (*hook_func)(event, obj); \
+ } \
+    } while (0)
+
+void
+rb_gc_add_event_hook(func, events)
+    rb_gc_event_hook_func_t func;
+    rb_gc_event_t events;
+{
+    rb_gc_event_hook_t *hook;
+
+    hook = ALLOC(rb_gc_event_hook_t);
+    hook->func = func;
+    hook->events = events;
+    hook->next = gc_event_hooks;
+    gc_event_hooks = hook;
+}
+
+int
+rb_gc_remove_event_hook(func)
+    rb_gc_event_hook_func_t func;
+{
+    rb_gc_event_hook_t *prev, *hook;
+
+    prev = NULL;
+    hook = gc_event_hooks;
+    while (hook) {
+ if (hook->func == func) {
+     if (prev) {
+   prev->next = hook->next;
+     }
+     else {
+   gc_event_hooks = hook->next;
+     }
+     xfree(hook);
+     return 0;
+ }
+ prev = hook;
+ hook = hook->next;
+    }
+    return -1;
+}
 
 NORETURN(void rb_exc_jump _((VALUE)));
 
@@ -1005,6 +1066,7 @@ rb_newobj()
 #endif
     live_objects++;
     allocated_objects++;
+    EXEC_GC_EVENT_HOOK(RUBY_GC_EVENT_NEWOBJ, obj);
     return obj;
 }
 
@@ -1888,6 +1950,7 @@ static int
 obj_free(obj)
     VALUE obj;
 {
+    EXEC_GC_EVENT_HOOK(RUBY_GC_EVENT_OBJFREE, obj);
     switch (BUILTIN_TYPE(obj)) {
       case T_NIL:
       case T_FIXNUM:
@@ -2186,6 +2249,7 @@ garbage_collect()
   /* This assumes that all registers are saved into the jmp_buf (and stack) */
   rb_setjmp(save_regs_gc_mark);
 
+  EXEC_GC_EVENT_HOOK(RUBY_GC_EVENT_START, Qnil);
 #if STACK_WIPE_SITES & 0x400
 # ifdef nativeAllocA
   if (__stack_past (top, stack_limit)) {
@@ -2206,6 +2270,7 @@ garbage_collect()
 #else
   garbage_collect_0(top);
 #endif
+  EXEC_GC_EVENT_HOOK(RUBY_GC_EVENT_END, Qnil);
 }
 
 void
@@ -3036,6 +3101,23 @@ rb_gc_set_copy_on_write_friendly(VALUE self, VALUE val)
 }
 
 /* call-seq:
+ *  ObjectSpace.free_slots => number
+ *
+ * Returns the count of object slots available for new objects. This goes
+ * after the garbage collector runs.
+ */
+static
+VALUE os_free_slots(VALUE self)
+{
+  int i;
+  unsigned long total_slots = 0;
+  for (i = 0; i < heaps_used; i++) {
+   total_slots += heaps[i].limit;
+  }
+  return ULONG2NUM(total_slots - live_objects);
+}
+
+/* call-seq:
  *  ObjectSpace.live_objects => number
  *
  * Returns the count of objects currently allocated in the system. This goes
@@ -3112,6 +3194,7 @@ Init_GC()
     rb_define_module_function(rb_mObSpace, "remove_finalizer", rm_final, 1);
     rb_define_module_function(rb_mObSpace, "finalizers", finals, 0);
     rb_define_module_function(rb_mObSpace, "call_finalizer", call_final, 1);
+    rb_define_module_function(rb_mObSpace, "free_slots", os_free_slots, 0);
     rb_define_module_function(rb_mObSpace, "live_objects", os_live_objects, 0);
     rb_define_module_function(rb_mObSpace, "allocated_objects", os_allocated_objects, 0);
 
diff --git a/node.h b/node.h
index 3e60603..af7a3fd 100644
--- a/source/node.h
+++ b/source/node.h
@@ -375,6 +375,19 @@ NODE *rb_copy_node_scope _((NODE *, NODE *));
 void rb_add_event_hook _((rb_event_hook_func_t,rb_event_t));
 int rb_remove_event_hook _((rb_event_hook_func_t));
 
+typedef unsigned int rb_gc_event_t;
+
+#define RUBY_GC_EVENT_NONE    0x00
+#define RUBY_GC_EVENT_START   0x01
+#define RUBY_GC_EVENT_END     0x02
+#define RUBY_GC_EVENT_NEWOBJ  0x04
+#define RUBY_GC_EVENT_OBJFREE 0x08
+#define RUBY_GC_EVENT_ALL     0xff
+
+typedef void (*rb_gc_event_hook_func_t) _((rb_gc_event_t,VALUE));
+void rb_gc_add_event_hook _((rb_gc_event_hook_func_t,rb_gc_event_t));
+int rb_gc_remove_event_hook _((rb_gc_event_hook_func_t));
+
 #if defined(HAVE_GETCONTEXT) && defined(HAVE_SETCONTEXT)
 #include <ucontext.h>
 #define USE_CONTEXT


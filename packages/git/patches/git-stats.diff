diff --git a/Makefile b/Makefile
index d2e2ea1..cf45c0e 100644
--- a/Makefile
+++ b/Makefile
@@ -542,6 +542,7 @@ LIB_H += run-command.h
 LIB_H += sha1-lookup.h
 LIB_H += sideband.h
 LIB_H += sigchain.h
+LIB_H += sockstat.h
 LIB_H += strbuf.h
 LIB_H += string-list.h
 LIB_H += submodule.h
@@ -549,6 +550,7 @@ LIB_H += tag.h
 LIB_H += transport.h
 LIB_H += tree.h
 LIB_H += tree-walk.h
+LIB_H += unix-socket.h
 LIB_H += unpack-trees.h
 LIB_H += userdiff.h
 LIB_H += utf8.h
@@ -647,6 +649,7 @@ LIB_OBJS += sha1_name.o
 LIB_OBJS += shallow.o
 LIB_OBJS += sideband.o
 LIB_OBJS += sigchain.o
+LIB_OBJS += sockstat.o
 LIB_OBJS += strbuf.o
 LIB_OBJS += string-list.o
 LIB_OBJS += submodule.o
@@ -658,6 +661,7 @@ LIB_OBJS += transport-helper.o
 LIB_OBJS += tree-diff.o
 LIB_OBJS += tree.o
 LIB_OBJS += tree-walk.o
+LIB_OBJS += unix-socket.o
 LIB_OBJS += unpack-trees.o
 LIB_OBJS += url.o
 LIB_OBJS += usage.o
diff --git a/builtin/index-pack.c b/builtin/index-pack.c
index 31f001f..f34651b 100644
--- a/builtin/index-pack.c
+++ b/builtin/index-pack.c
@@ -9,6 +9,7 @@
 #include "progress.h"
 #include "fsck.h"
 #include "exec_cmd.h"
+#include "sockstat.h"
 
 static const char index_pack_usage[] =
 "git index-pack [-v] [-o <index-file>] [ --keep | --keep=<msg> ] [--strict] (<pack-file> | --stdin [--fix-thin] [<pack-file>])";
@@ -144,8 +145,11 @@ static void flush(void)
 			die_errno("read error on input");
 		}
 		input_len += ret;
-		if (from_stdin)
+		if (from_stdin) {
 			display_throughput(progress, consumed_bytes + input_len);
+			sockstat_unsigned("receiving_objects_bytes", throughput_total(progress));
+			sockstat_unsigned("receiving_objects_rate", throughput_rate(progress));
+		}
 	} while (input_len < min);
 	return input_buffer;
 }
@@ -604,6 +608,14 @@ static void parse_pack_objects(unsigned char *sha1)
 		progress = start_progress(
 				from_stdin ? "Receiving objects" : "Indexing objects",
 				nr_objects);
+	if (from_stdin) {
+		if (!verbose)
+			progress = start_progress_silent(
+				from_stdin ? "Receiving objects" : "Indexing objects",
+				nr_objects);
+		sockstat_string("status", "receiving");
+		sockstat_unsigned("receiving_objects_total", nr_objects);
+	}
 	for (i = 0; i < nr_objects; i++) {
 		struct object_entry *obj = &objects[i];
 		void *data = unpack_raw_entry(obj, &delta->base);
@@ -616,6 +628,8 @@ static void parse_pack_objects(unsigned char *sha1)
 			sha1_object(data, obj->size, obj->type, obj->idx.sha1);
 		free(data);
 		display_progress(progress, i+1);
+		if (from_stdin)
+			sockstat_unsigned("receiving_objects", i+1);
 	}
 	objects[i].idx.offset = consumed_bytes;
 	stop_progress(&progress);
@@ -651,6 +665,10 @@ static void parse_pack_objects(unsigned char *sha1)
 	 */
 	if (verbose)
 		progress = start_progress("Resolving deltas", nr_deltas);
+	if (from_stdin) {
+		sockstat_string("status", "resolving");
+		sockstat_unsigned("resolving_deltas_total", nr_deltas);
+	}
 	for (i = 0; i < nr_objects; i++) {
 		struct object_entry *obj = &objects[i];
 		struct base_data base_obj;
@@ -661,6 +679,8 @@ static void parse_pack_objects(unsigned char *sha1)
 		base_obj.data = NULL;
 		find_unresolved_deltas(&base_obj, NULL);
 		display_progress(progress, nr_resolved_deltas);
+		if (from_stdin)
+			sockstat_unsigned("resolving_deltas", nr_resolved_deltas);
 	}
 }
 
@@ -767,6 +787,8 @@ static void fix_unresolved_deltas(struct sha1file *f, int nr_unresolved)
 					base_obj.data, base_obj.size, type);
 		find_unresolved_deltas(&base_obj, NULL);
 		display_progress(progress, nr_resolved_deltas);
+		if (from_stdin)
+			sockstat_unsigned("resolving_deltas", nr_resolved_deltas);
 	}
 	free(sorted_by_pos);
 }
@@ -965,6 +987,9 @@ int cmd_index_pack(int argc, const char **argv, const char *prefix)
 		keep_name = keep_name_buf;
 	}
 
+	if (from_stdin)
+		sockstat_init("index-pack");
+
 	curr_pack = open_pack_file(pack_name);
 	parse_pack_header();
 	objects = xmalloc((nr_objects + 1) * sizeof(struct object_entry));
diff --git a/builtin/pack-objects.c b/builtin/pack-objects.c
index f402a84..40eecb5 100644
--- a/builtin/pack-objects.c
+++ b/builtin/pack-objects.c
@@ -17,6 +17,7 @@
 #include "progress.h"
 #include "refs.h"
 #include "thread-utils.h"
+#include "sockstat.h"
 
 static const char pack_usage[] =
   "git pack-objects [ -q | --progress | --all-progress ]\n"
@@ -442,8 +443,13 @@ static void write_pack_file(void)
 	uint32_t nr_remaining = nr_result;
 	time_t last_mtime = 0;
 
+	sockstat_string("status", "writing");
+	sockstat_unsigned("writing_objects_total", nr_result);
+
 	if (progress > pack_to_stdout)
 		progress_state = start_progress("Writing objects", nr_result);
+	else if (1) /* measure throughput for sockstat without printing progress */
+		progress_state = start_progress_silent("Writing objects", nr_result);
 	written_list = xmalloc(nr_objects * sizeof(*written_list));
 
 	do {
@@ -471,6 +477,11 @@ static void write_pack_file(void)
 			if (!write_one(f, objects + i, &offset))
 				break;
 			display_progress(progress_state, written);
+			if (i > 0) {
+				sockstat_unsigned("writing_objects", written);
+				sockstat_unsigned("writing_objects_bytes", throughput_total(progress_state));
+				sockstat_unsigned("writing_objects_rate", throughput_rate(progress_state));
+			}
 		}
 
 		/*
@@ -706,6 +717,7 @@ static int add_object_entry(const unsigned char *sha1, enum object_type type,
 	else
 		object_ix[-1 - ix] = nr_objects;
 
+	sockstat_unsigned("counting_objects", nr_objects);
 	display_progress(progress_state, nr_objects);
 
 	if (name && no_try_delta(name))
@@ -1422,6 +1434,7 @@ static void find_deltas(struct object_entry **list, unsigned *list_size,
 		(*list_size)--;
 		if (!entry->preferred_base) {
 			(*processed)++;
+			sockstat_unsigned("compressing_objects", *processed);
 			display_progress(progress_state, *processed);
 		}
 		progress_unlock();
@@ -1828,6 +1841,10 @@ static void prepare_pack(int window, int depth)
 
 	if (nr_deltas && n > 1) {
 		unsigned nr_done = 0;
+
+		sockstat_string("status", "compressing");
+		sockstat_unsigned("compressing_objects_total", nr_deltas);
+
 		if (progress)
 			progress_state = start_progress("Compressing objects",
 							nr_deltas);
@@ -2333,6 +2350,9 @@ int cmd_pack_objects(int argc, const char **argv, const char *prefix)
 
 	prepare_packed_git();
 
+	sockstat_init("pack-objects");
+	sockstat_string("status", "counting");
+
 	if (progress)
 		progress_state = start_progress("Counting objects", 0);
 	if (!use_internal_rev_list)
@@ -2351,6 +2371,11 @@ int cmd_pack_objects(int argc, const char **argv, const char *prefix)
 	if (nr_result)
 		prepare_pack(window, depth);
 	write_pack_file();
+
+	sockstat_unsigned("written", written);
+	sockstat_unsigned("written_delta", written_delta);
+	sockstat_unsigned("reused", reused);
+	sockstat_unsigned("reused_delta", reused_delta);
 	if (progress)
 		fprintf(stderr, "Total %"PRIu32" (delta %"PRIu32"),"
 			" reused %"PRIu32" (delta %"PRIu32")\n",
diff --git a/builtin/receive-pack.c b/builtin/receive-pack.c
index e1ba4dc..067d03b 100644
--- a/builtin/receive-pack.c
+++ b/builtin/receive-pack.c
@@ -1,6 +1,7 @@
 #include "builtin.h"
 #include "pack.h"
 #include "refs.h"
+#include "sockstat.h"
 #include "pkt-line.h"
 #include "sideband.h"
 #include "run-command.h"
@@ -121,6 +122,7 @@ static int show_ref(const char *path, const unsigned char *sha1, int flag, void
 
 static void write_head_info(void)
 {
+	sockstat_string("status", "show_ref");
 	for_each_ref(show_ref, NULL);
 	if (!sent_capabilities)
 		show_ref("capabilities^{}", null_sha1, 0, NULL);
@@ -335,6 +337,7 @@ static void refuse_unconfigured_deny_delete_current(void)
 	unsigned char *old_sha1 = cmd->old_sha1;
 	unsigned char *new_sha1 = cmd->new_sha1;
 	struct ref_lock *lock;
+	struct strbuf *sockstat_json;
 
 	/* only refs/... are allowed */
 	if (prefixcmp(name, "refs/") || check_ref_format(name + 5)) {
@@ -387,7 +390,7 @@ static void refuse_unconfigured_deny_delete_current(void)
 		}
 	}
 
-	if (deny_non_fast_forwards && !is_null_sha1(new_sha1) &&
+	if (1/*sockstat*/ && !is_null_sha1(new_sha1) &&
 	    !is_null_sha1(old_sha1) &&
 	    !prefixcmp(name, "refs/heads/")) {
 		struct object *old_object, *new_object;
@@ -411,11 +414,18 @@ static void refuse_unconfigured_deny_delete_current(void)
 				break;
 		free_commit_list(bases);
 		if (!ent) {
-			rp_error("denying non-fast-forward %s"
-				 " (you should pull first)", name);
-			return "non-fast-forward";
+			sockstat_bool("non_fast_forward", 1);
+			if (deny_non_fast_forwards) {
+				rp_error("denying non-fast-forward %s"
+					 " (you should pull first)", name);
+				return "non-fast-forward";
+			}
+		} else {
+			sockstat_bool("non_fast_forward", 0);
 		}
 	}
+	sockstat_string("current_ref", name);
+	sockstat_string("status", "update_hook");
 	if (run_update_hook(cmd)) {
 		rp_error("hook declined to update %s", name);
 		return "hook declined";
@@ -438,7 +448,8 @@ static void refuse_unconfigured_deny_delete_current(void)
 			rp_error("failed to lock %s", name);
 			return "failed to lock";
 		}
-		if (write_ref_sha1(lock, new_sha1, "push")) {
+		sockstat_json = sockstat_as_json();
+		if (write_ref_sha1(lock, new_sha1, sockstat_json->buf)) {
 			return "failed to write"; /* error() already called */
 		}
 		return NULL; /* good */
@@ -556,6 +567,7 @@ static void execute_commands(struct command *commands, const char *unpacker_erro
 		return;
 	}
 
+	sockstat_string("status", "pre_recieve_hook");
 	if (run_receive_hook(commands, pre_receive_hook)) {
 		for (cmd = commands; cmd; cmd = cmd->next)
 			cmd->error_string = "pre-receive hook declined";
@@ -575,6 +587,7 @@ static void execute_commands(struct command *commands, const char *unpacker_erro
 {
 	struct command *commands = NULL;
 	struct command **p = &commands;
+	sockstat_string("status", "read_head_info");
 	for (;;) {
 		static char line[1000];
 		unsigned char old_sha1[20], new_sha1[20];
@@ -782,6 +795,7 @@ int cmd_receive_pack(int argc, const char **argv, const char *prefix)
 	if (is_repository_shallow())
 		die("attempt to push into a shallow repository");
 
+	sockstat_init("receive-pack");
 	git_config(receive_pack_config, NULL);
 
 	if (0 <= transfer_unpack_limit)
@@ -810,7 +824,9 @@ int cmd_receive_pack(int argc, const char **argv, const char *prefix)
 			unlink_or_warn(pack_lockfile);
 		if (report_status)
 			report(commands, unpack_status);
+		sockstat_string("status", "post_recieve_hook");
 		run_receive_hook(commands, post_receive_hook);
+		sockstat_string("status", "post_update_hook");
 		run_update_post_hook(commands);
 		if (auto_gc) {
 			const char *argv_gc_auto[] = {
diff --git a/builtin/unpack-objects.c b/builtin/unpack-objects.c
index f63973c..50af9b3 100644
--- a/builtin/unpack-objects.c
+++ b/builtin/unpack-objects.c
@@ -11,6 +11,7 @@
 #include "progress.h"
 #include "decorate.h"
 #include "fsck.h"
+#include "sockstat.h"
 
 static int dry_run, quiet, recover, has_errors, strict;
 static const char unpack_usage[] = "git unpack-objects [-n] [-q] [-r] [--strict] < pack-file";
@@ -479,11 +480,15 @@ static void unpack_all(void)
 			ntohl(hdr->hdr_version));
 	use(sizeof(struct pack_header));
 
+	sockstat_string("status", "unpacking");
+	sockstat_unsigned("unpacking_objects_total", nr_objects);
+
 	if (!quiet)
 		progress = start_progress("Unpacking objects", nr_objects);
 	obj_list = xcalloc(nr_objects, sizeof(*obj_list));
 	for (i = 0; i < nr_objects; i++) {
 		unpack_one(i);
+		sockstat_unsigned("unpacking_objects", i + 1);
 		display_progress(progress, i + 1);
 	}
 	stop_progress(&progress);
@@ -544,6 +549,7 @@ int cmd_unpack_objects(int argc, const char **argv, const char *prefix)
 		/* We don't take any non-flag arguments now.. Maybe some day */
 		usage(unpack_usage);
 	}
+	sockstat_init("unpack-objects");
 	git_SHA1_Init(&ctx);
 	unpack_all();
 	git_SHA1_Update(&ctx, buffer, offset);
diff --git a/daemon.c b/daemon.c
index 4c8346d..b4033a4 100644
--- a/daemon.c
+++ b/daemon.c
@@ -441,9 +441,22 @@ static void parse_host_arg(char *extra_args, int buflen)
 	int vallen;
 	char *end = extra_args + buflen;
 
-	if (extra_args < end && *extra_args) {
+	while (extra_args < end && *extra_args) {
 		saw_extended_args = 1;
-		if (strncasecmp("host=", extra_args, 5) == 0) {
+
+		if (strncasecmp("stat=", extra_args, 5) == 0) {
+			val = extra_args + 5;
+			vallen = strlen(val) + 1;
+			if (*val) {
+				char var[8192] = "GIT_SOCKSTAT_VAR_";
+				strncat(var, val, 8192-vallen);
+				putenv(strdup(var));
+			}
+
+			/* On to the next one */
+			extra_args = val + vallen;
+		}
+		else if (strncasecmp("host=", extra_args, 5) == 0) {
 			val = extra_args + 5;
 			vallen = strlen(val) + 1;
 			if (*val) {
@@ -462,7 +475,7 @@ static void parse_host_arg(char *extra_args, int buflen)
 			/* On to the next one */
 			extra_args = val + vallen;
 		}
-		if (extra_args < end && *extra_args)
+		else if (extra_args < end && *extra_args)
 			die("Invalid request");
 	}
 
diff --git a/git-compat-util.h b/git-compat-util.h
index 40498b3..7c49937 100644
--- a/git-compat-util.h
+++ b/git-compat-util.h
@@ -130,6 +130,7 @@
 #include <arpa/inet.h>
 #include <netdb.h>
 #include <pwd.h>
+#include <sys/un.h>
 #ifndef NO_INTTYPES_H
 #include <inttypes.h>
 #else
@@ -215,6 +216,10 @@
 #define is_dir_sep(c) ((c) == '/')
 #endif
 
+#ifndef find_last_dir_sep
+#define find_last_dir_sep(path) strrchr(path, '/')
+#endif
+
 #if __HP_cc >= 61000
 #define NORETURN __attribute__((noreturn))
 #define NORETURN_PTR
diff --git a/progress.c b/progress.c
index 3971f49..a72a70e 100644
--- a/progress.c
+++ b/progress.c
@@ -32,6 +32,7 @@ struct progress {
 	unsigned last_percent;
 	unsigned delay;
 	unsigned delayed_percent_treshold;
+	unsigned silent;
 	struct throughput *throughput;
 };
 
@@ -72,6 +73,8 @@ static void clear_progress_signal(void)
 static int display(struct progress *progress, unsigned n, const char *done)
 {
 	const char *eol, *tp;
+	if (progress->silent)
+		return 0;
 
 	if (progress->delay) {
 		if (!progress_update || --progress->delay)
@@ -142,6 +145,32 @@ static void throughput_string(struct throughput *tp, off_t total,
 			 " | %u KiB/s", rate);
 }
 
+unsigned throughput_total(struct progress *progress)
+{
+	struct throughput *tp;
+
+	if (!progress)
+		return 0;
+	tp = progress->throughput;
+	if (!tp)
+		return 0;
+
+	return tp->curr_total;
+}
+
+unsigned throughput_rate(struct progress *progress)
+{
+	struct throughput *tp;
+
+	if (!progress)
+		return 0;
+	tp = progress->throughput;
+	if (!tp || !tp->avg_misecs)
+		return 0;
+
+	return tp->avg_bytes / tp->avg_misecs;
+}
+
 void display_throughput(struct progress *progress, off_t total)
 {
 	struct throughput *tp;
@@ -224,6 +253,7 @@ struct progress *start_progress_delay(const char *title, unsigned total,
 	progress->last_percent = -1;
 	progress->delayed_percent_treshold = percent_treshold;
 	progress->delay = delay;
+	progress->silent = 0;
 	progress->throughput = NULL;
 	set_progress_signal();
 	return progress;
@@ -234,6 +264,14 @@ struct progress *start_progress(const char *title, unsigned total)
 	return start_progress_delay(title, total, 0, 0);
 }
 
+struct progress *start_progress_silent(const char *title, unsigned total)
+{
+	struct progress *progress = start_progress_delay(title, total, 0, 0);
+	progress->silent = 1;
+	clear_progress_signal();
+	return progress;
+}
+
 void stop_progress(struct progress **p_progress)
 {
 	stop_progress_msg(p_progress, "done");
@@ -245,6 +283,9 @@ void stop_progress_msg(struct progress **p_progress, const char *msg)
 	if (!progress)
 		return;
 	*p_progress = NULL;
+	if (progress->silent)
+		return;
+
 	if (progress->last_value != -1) {
 		/* Force the last update */
 		char buf[128], *bufp;
diff --git a/progress.h b/progress.h
index 611e4c4..2ef525f 100644
--- a/progress.h
+++ b/progress.h
@@ -4,8 +4,11 @@
 struct progress;
 
 void display_throughput(struct progress *progress, off_t total);
+unsigned throughput_total(struct progress *progress);
+unsigned throughput_rate(struct progress *progress);
 int display_progress(struct progress *progress, unsigned n);
 struct progress *start_progress(const char *title, unsigned total);
+struct progress *start_progress_silent(const char *title, unsigned total);
 struct progress *start_progress_delay(const char *title, unsigned total,
 				       unsigned percent_treshold, unsigned delay);
 void stop_progress(struct progress **progress);
diff --git a/script/cibuild b/script/cibuild
new file mode 100755
index 0000000..eb05259
--- /dev/null
+++ b/script/cibuild
@@ -0,0 +1,2 @@
+#!/bin/sh
+make test
diff --git a/sockstat.c b/sockstat.c
new file mode 100644
index 0000000..f63ceb4
--- /dev/null
+++ b/sockstat.c
@@ -0,0 +1,490 @@
+#include "cache.h"
+#include "git-compat-util.h"
+#include "sockstat.h"
+#include "strbuf.h"
+#include "unix-socket.h"
+#include "quote.h"
+
+extern char **environ;
+
+typedef struct sockstat_entry {
+	const char *name;
+	union {
+		uintmax_t uint;
+		char *str;
+		uintmax_t bool;
+	} as;
+	enum {
+		SOCKSTAT_TYPE_NONE,
+		SOCKSTAT_TYPE_UINT,
+		SOCKSTAT_TYPE_STR,
+		SOCKSTAT_TYPE_BOOL
+	} type;
+	unsigned pending;
+} sockstat_entry_t;
+
+static int sockstat_enabled = 0;
+static int fd = -1, sockstat_streaming = 0;
+static volatile sig_atomic_t sigurg_pending;
+
+static struct strbuf packet = STRBUF_INIT;
+static void sockstat_send_all();
+
+#define MAX_SOCKSTAT_ENTRIES 128
+static int sockstat_entries_used = 0;
+static int sockstat_entries_pending = 0;
+static sockstat_entry_t sockstat_entries[MAX_SOCKSTAT_ENTRIES];
+
+static void lowercase(char *p)
+{
+	for (; *p; p++)
+		*p = tolower(*p);
+}
+
+static sockstat_entry_t *sockstat_entry_for_name(const char *name)
+{
+	int i;
+	for (i = sockstat_entries_used - 1; i >= 0; i--) {
+		sockstat_entry_t *entry = &sockstat_entries[i];
+		if (strcmp(entry->name, name) == 0)
+			return entry;
+	}
+
+	if (sockstat_entries_used < MAX_SOCKSTAT_ENTRIES) {
+		sockstat_entry_t *entry = &sockstat_entries[sockstat_entries_used++];
+		entry->name = strdup(name);
+		return entry;
+	}
+
+	return NULL;
+}
+
+static void sockstat_close(void)
+{
+	if (fd >= 0)
+		close(fd);
+	fd = -1;
+}
+
+void sockstat_connect()
+{
+	const char *path = getenv("GIT_SOCKSTAT_PATH");
+
+	if (!path)
+		path = "/tmp/gitstats.sock";
+	if (fd != -1)
+		return;
+
+	fd = unix_stream_connect(path);
+	if (fd < 0)
+		return;
+	if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0) {
+		sockstat_close();
+		return;
+	}
+	if (fcntl(fd, F_SETFD, O_CLOEXEC) < 0) {
+		sockstat_close();
+		return;
+	}
+#ifdef SO_NOSIGPIPE
+	int set = 1;
+	if (setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, (void *)&set, sizeof(int)) < 0) {
+		sockstat_close();
+		return;
+	}
+#endif
+}
+
+void sockstat_sigurg_handler(int signal)
+{
+	sigurg_pending = 1;
+}
+
+void sockstat_import_env()
+{
+	const char *remote_addr = getenv("REMOTE_ADDR");
+	const char *remote_port = getenv("REMOTE_PORT");
+	const char *pusher = getenv("GIT_PUSHER");
+	const char *ssh = getenv("SSH_CONNECTION");
+	const char *real_ip = getenv("HTTP_X_REAL_IP");
+	const char *user_agent = getenv("HTTP_USER_AGENT");
+
+	if (remote_addr)
+		sockstat_string("remote_addr", remote_addr);
+	if (remote_port)
+		sockstat_string("remote_port", remote_port);
+	if (pusher && strlen(pusher))
+		sockstat_string("pusher", pusher);
+	if (ssh)
+		sockstat_string("ssh_connection", ssh);
+	if (real_ip)
+		sockstat_string("real_ip", real_ip);
+	if (user_agent)
+		sockstat_string("user_agent", user_agent);
+}
+
+void sockstat_import_vars()
+{
+	char **curr = environ;
+	char *var, *varend, *value, *key;
+	const char *name, *data;
+
+	if (!curr)
+		return;
+
+	for (; *curr != NULL; ++curr) {
+		var = *curr;
+		varend = var + strlen(var);
+
+		name = skip_prefix(var, "GIT_SOCKSTAT_VAR_");
+		if (!name)
+			name = skip_prefix(var, "HTTP_X_SOCKSTAT_");
+		if (!name)
+			continue;
+		if (!*name)
+			continue;
+
+		value = strchr(name, '=');
+		if (!value || value == name)
+			continue;
+
+		++value;
+		if (value >= varend)
+			continue;
+
+		key = strndup(name, value - name - 1);
+		lowercase(key);
+
+		if ((data = skip_prefix(value, "uint:"))) {
+			sockstat_unsigned(key, strtoumax(data, NULL, 10));
+		} else if ((data = skip_prefix(value, "bool:"))) {
+			sockstat_bool(key, data[0] == 't' || data[0] == '1' ? 1 : 0);
+		} else {
+			sockstat_string(key, value);
+		}
+
+		free(key);
+	}
+}
+
+void sockstat_init(const char *program)
+{
+	sockstat_enabled = 1;
+
+	sockstat_unsigned("pid", getpid());
+	sockstat_unsigned("ppid", getppid());
+	sockstat_string("program", program);
+	sockstat_string("git_dir", real_path(get_git_dir()));
+
+	sockstat_import_env();
+	sockstat_import_vars();
+
+	char *streaming = getenv("GIT_SOCKSTAT_STREAMING");
+	if (!streaming || streaming[0] != '0') {
+		sockstat_streaming = 1;
+		sockstat_connect();
+		sockstat_send_all();
+	}
+	signal(SIGURG, sockstat_sigurg_handler);
+}
+
+static int check_fd_writable(int fd, int msecs)
+{
+	fd_set set;
+	struct timeval tv;
+	int r;
+
+	FD_ZERO(&set);
+	FD_SET(fd, &set);
+	tv.tv_sec = msecs/1000;
+	tv.tv_usec = (msecs - tv.tv_sec*1000) * 1000;
+
+retry:
+	r = select(fd+1, NULL, &set, NULL, &tv);
+	if (r < 0 && errno == EINTR)
+		goto retry;
+	return r > 0;
+}
+
+static void sockstat_write(const char *buf, int len)
+{
+	if (fd < 0)
+		return;
+
+	while (len > 0) {
+		int r;
+
+		if (!check_fd_writable(fd, 250)) {
+			sockstat_close();
+			return;
+		}
+
+#ifdef MSG_NOSIGNAL
+		r = send(fd, buf, len, MSG_NOSIGNAL);
+#else
+		r = write(fd, buf, len);
+#endif
+
+		if (r < 0) {
+			if (errno == EINTR || errno == EAGAIN)
+				continue;
+			sockstat_close();
+			return;
+		}
+
+		buf += r;
+		len -= r;
+	}
+}
+
+static void sockstat_send(struct strbuf *packet)
+{
+	sockstat_write(packet->buf, packet->len);
+}
+
+void quote_json_string(struct strbuf *buf, const char *str)
+{
+	const char *hexchar = "0123456789ABCDEF";
+	int i, len;
+	unsigned char c;
+
+	if (!str)
+		strbuf_addstr(buf, "null");
+	else {
+		len = strlen(str);
+		strbuf_grow(buf, len+2);
+
+		strbuf_addch(buf, '"');
+		for (i = 0; i < len; i++) {
+			c = str[i];
+
+			switch (c) {
+				case '"':
+				case '\\':
+					strbuf_addch(buf, '\\');
+					strbuf_addch(buf, c);
+					break;
+				case '\b':
+					strbuf_addstr(buf, "\\b");
+					break;
+				case '\f':
+					strbuf_addstr(buf, "\\f");
+					break;
+				case '\n':
+					strbuf_addstr(buf, "\\n");
+					break;
+				case '\r':
+					strbuf_addstr(buf, "\\r");
+					break;
+				case '\t':
+					strbuf_addstr(buf, "\\t");
+					break;
+				default:
+					if (c < 32) {
+						strbuf_addstr(buf, "\\u00");
+						strbuf_addch(buf, hexchar[c >> 4]);
+						strbuf_addch(buf, hexchar[c & 0x0F]);
+					} else
+						strbuf_addch(buf, c);
+			}
+		}
+		strbuf_addch(buf, '"');
+	}
+}
+
+static void sockstat_build_json(unsigned pending_only)
+{
+	int i, n, started = 0;
+	if (pending_only && sockstat_entries_pending == 0)
+		return;
+
+	strbuf_reset(&packet);
+	strbuf_addstr(&packet, "{ ");
+	for (i = 0, n = 0; i < sockstat_entries_used; i++) {
+		sockstat_entry_t *entry = &sockstat_entries[i];
+
+		if (pending_only) {
+			if (n == sockstat_entries_pending)
+				break;
+
+			if (entry->pending)
+				entry->pending = 0;
+			else
+				continue;
+
+			n++;
+		}
+
+		if (started)
+			strbuf_addstr(&packet, ", ");
+		started = 1;
+
+		strbuf_addf(&packet, "\"%s\":", entry->name);
+		switch (entry->type) {
+			case SOCKSTAT_TYPE_STR:
+				quote_json_string(&packet, entry->as.str);
+				break;
+			case SOCKSTAT_TYPE_UINT:
+				strbuf_addf(&packet, "%"PRIuMAX, entry->as.uint);
+				break;
+			case SOCKSTAT_TYPE_BOOL:
+				strbuf_addstr(&packet, entry->as.bool ? "true" : "false");
+				break;
+			default:
+				strbuf_addstr(&packet, "null");
+		}
+	}
+	strbuf_addstr(&packet, " }");
+}
+
+static void sockstat_send_entries(unsigned pending_only)
+{
+	sockstat_build_json(pending_only);
+	strbuf_addch(&packet, '\n');
+	sockstat_send(&packet);
+	sockstat_entries_pending = 0;
+}
+
+struct strbuf *sockstat_as_json()
+{
+	sockstat_build_json(0);
+	return &packet;
+}
+
+static void sockstat_send_all()
+{
+	if (fd == -1)
+		sockstat_connect();
+	if (fd == -1)
+		return;
+
+	sockstat_send_entries(0);
+	sigurg_pending = 0;
+
+	// In streaming mode, we assume the other side is going to be sticking
+	// around and so we keep the socket open. Otherwise, we assume the remote
+	// end is only around for the duration of this request. We close the socket
+	// explicitly here, so the next signal doesn't try to write to a broken fd.
+	if (!sockstat_streaming)
+		sockstat_close();
+}
+
+static void sockstat_flush_maybe()
+{
+	static struct timeval last_flush = {0,};
+	struct timeval now;
+	unsigned msec;
+
+	if (!gettimeofday(&now, NULL)) {
+		if (!last_flush.tv_sec)
+			last_flush = now;
+
+		msec = (now.tv_sec - last_flush.tv_sec) * 1000;
+		msec += (now.tv_usec - last_flush.tv_usec) / 1000;
+
+		if (msec > 500) {
+			sockstat_flush();
+			last_flush = now;
+		}
+	}
+}
+
+void sockstat_flush()
+{
+	if (!sockstat_enabled)
+		return;
+
+	sockstat_send_entries(1);
+}
+
+void sockstat_bool(const char *name, uintmax_t value)
+{
+	if (!sockstat_enabled)
+		return;
+
+	sockstat_entry_t *entry = sockstat_entry_for_name(name);
+	if (entry) {
+		entry->type = SOCKSTAT_TYPE_BOOL;
+		entry->as.bool = value;
+	}
+
+	if (sigurg_pending)
+		return sockstat_send_all();
+
+	if (sockstat_streaming) {
+		if (fd < 0)
+			return;
+
+		entry->pending = 1;
+		sockstat_entries_pending++;
+		sockstat_flush();
+	}
+}
+
+void sockstat_unsigned(const char *name, uintmax_t value)
+{
+	if (!sockstat_enabled)
+		return;
+
+	unsigned new_entry = 0;
+
+	sockstat_entry_t *entry = sockstat_entry_for_name(name);
+	if (entry) {
+		if (entry->type == SOCKSTAT_TYPE_NONE)
+			new_entry = 1;
+		entry->type = SOCKSTAT_TYPE_UINT;
+		entry->as.uint = value;
+	}
+
+	if (sigurg_pending)
+		return sockstat_send_all();
+
+	if (sockstat_streaming) {
+		if (fd < 0)
+			return;
+
+		entry->pending = 1;
+		sockstat_entries_pending++;
+
+		if (new_entry)
+			sockstat_flush();
+		else
+			sockstat_flush_maybe();
+	}
+}
+
+void sockstat_string(const char *name, const char *value)
+{
+	if (!sockstat_enabled)
+		return;
+
+	sockstat_entry_t *entry = sockstat_entry_for_name(name);
+	if (entry) {
+		entry->type = SOCKSTAT_TYPE_STR;
+		if (entry->as.str)
+			free(entry->as.str);
+		entry->as.str = strdup(value);
+	}
+
+	if (sigurg_pending)
+		return sockstat_send_all();
+
+	if (sockstat_streaming) {
+		if (fd < 0)
+			return;
+
+		entry->pending = 1;
+		sockstat_entries_pending++;
+		sockstat_flush();
+	}
+}
+
+void sockstat_valist(const char *name, const char *fmt, va_list params)
+{
+	if (!sockstat_enabled)
+		return;
+
+	char val[1024];
+	vsnprintf(val, sizeof(val), fmt, params);
+	sockstat_string(name, val);
+}
diff --git a/sockstat.h b/sockstat.h
new file mode 100644
index 0000000..e130eb4
--- /dev/null
+++ b/sockstat.h
@@ -0,0 +1,14 @@
+#ifndef SOCKSTATS_H
+#define SOCKSTATS_H
+
+#include "strbuf.h"
+
+void sockstat_init(const char *program);
+void sockstat_bool(const char *name, uintmax_t value);
+void sockstat_unsigned(const char *name, uintmax_t value);
+void sockstat_string(const char *name, const char *value);
+void sockstat_valist(const char *name, const char *fmt, va_list params);
+struct strbuf *sockstat_as_json();
+void sockstat_flush();
+
+#endif /* SOCKSTATS_H */
diff --git a/unix-socket.c b/unix-socket.c
new file mode 100644
index 0000000..01f119f
--- /dev/null
+++ b/unix-socket.c
@@ -0,0 +1,122 @@
+#include "cache.h"
+#include "unix-socket.h"
+
+static int unix_stream_socket(void)
+{
+	int fd = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (fd < 0)
+		die_errno("unable to create socket");
+	return fd;
+}
+
+static int chdir_len(const char *orig, int len)
+{
+	char *path = xmemdupz(orig, len);
+	int r = chdir(path);
+	free(path);
+	return r;
+}
+
+struct unix_sockaddr_context {
+	char orig_dir[PATH_MAX];
+};
+
+static void unix_sockaddr_cleanup(struct unix_sockaddr_context *ctx)
+{
+	if (!ctx->orig_dir[0])
+		return;
+	/*
+	 * If we fail, we can't just return an error, since we have
+	 * moved the cwd of the whole process, which could confuse calling
+	 * code.  We are better off to just die.
+	 */
+	if (chdir(ctx->orig_dir) < 0)
+		die("unable to restore original working directory");
+}
+
+static int unix_sockaddr_init(struct sockaddr_un *sa, const char *path,
+			      struct unix_sockaddr_context *ctx)
+{
+	int size = strlen(path) + 1;
+
+	ctx->orig_dir[0] = '\0';
+	if (size > sizeof(sa->sun_path)) {
+		const char *slash = find_last_dir_sep(path);
+		const char *dir;
+
+		if (!slash) {
+			errno = ENAMETOOLONG;
+			return -1;
+		}
+
+		dir = path;
+		path = slash + 1;
+		size = strlen(path) + 1;
+		if (size > sizeof(sa->sun_path)) {
+			errno = ENAMETOOLONG;
+			return -1;
+		}
+
+		if (!getcwd(ctx->orig_dir, sizeof(ctx->orig_dir))) {
+			errno = ENAMETOOLONG;
+			return -1;
+		}
+		if (chdir_len(dir, slash - dir) < 0)
+			return -1;
+	}
+
+	memset(sa, 0, sizeof(*sa));
+	sa->sun_family = AF_UNIX;
+	memcpy(sa->sun_path, path, size);
+	return 0;
+}
+
+int unix_stream_connect(const char *path)
+{
+	int fd, saved_errno;
+	struct sockaddr_un sa;
+	struct unix_sockaddr_context ctx;
+
+	if (unix_sockaddr_init(&sa, path, &ctx) < 0)
+		return -1;
+	fd = unix_stream_socket();
+	if (connect(fd, (struct sockaddr *)&sa, sizeof(sa)) < 0)
+		goto fail;
+	unix_sockaddr_cleanup(&ctx);
+	return fd;
+
+fail:
+	saved_errno = errno;
+	unix_sockaddr_cleanup(&ctx);
+	close(fd);
+	errno = saved_errno;
+	return -1;
+}
+
+int unix_stream_listen(const char *path)
+{
+	int fd, saved_errno;
+	struct sockaddr_un sa;
+	struct unix_sockaddr_context ctx;
+
+	if (unix_sockaddr_init(&sa, path, &ctx) < 0)
+		return -1;
+	fd = unix_stream_socket();
+
+	unlink(path);
+	if (bind(fd, (struct sockaddr *)&sa, sizeof(sa)) < 0)
+		goto fail;
+
+	if (listen(fd, 5) < 0)
+		goto fail;
+
+	unix_sockaddr_cleanup(&ctx);
+	return fd;
+
+fail:
+	saved_errno = errno;
+	unix_sockaddr_cleanup(&ctx);
+	close(fd);
+	errno = saved_errno;
+	return -1;
+}
diff --git a/unix-socket.h b/unix-socket.h
new file mode 100644
index 0000000..e271aee
--- /dev/null
+++ b/unix-socket.h
@@ -0,0 +1,7 @@
+#ifndef UNIX_SOCKET_H
+#define UNIX_SOCKET_H
+
+int unix_stream_connect(const char *path);
+int unix_stream_listen(const char *path);
+
+#endif /* UNIX_SOCKET_H */
diff --git a/upload-pack.c b/upload-pack.c
index ce5cbbe..7f330b4 100644
--- a/upload-pack.c
+++ b/upload-pack.c
@@ -10,6 +10,7 @@
 #include "revision.h"
 #include "list-objects.h"
 #include "run-command.h"
+#include "sockstat.h"
 
 static const char upload_pack_usage[] = "git upload-pack [--strict] [--timeout=<n>] <dir>";
 
@@ -57,6 +58,12 @@ static int strip(char *line, int len)
 
 static ssize_t send_client_data(int fd, const char *data, ssize_t sz)
 {
+	static ssize_t total = 0;
+
+	total += sz;
+	sockstat_unsigned("bytes_sent", total);
+	sockstat_unsigned("last_sent", time(NULL));
+
 	if (use_sideband)
 		return send_sideband(1, fd, data, sz, use_sideband);
 	if (fd == 3)
@@ -680,20 +687,29 @@ static void upload_pack(void)
 {
 	if (advertise_refs || !stateless_rpc) {
 		reset_timeout();
+		sockstat_string("status", "send_ref");
 		head_ref(send_ref, NULL);
 		for_each_ref(send_ref, NULL);
 		packet_flush(1);
 	} else {
+		sockstat_string("status", "mark_our_ref");
 		head_ref(mark_our_ref, NULL);
 		for_each_ref(mark_our_ref, NULL);
 	}
 	if (advertise_refs)
 		return;
 
+	sockstat_string("status", "receive_needs");
 	receive_needs();
 	if (want_obj.nr) {
+		sockstat_string("status", "get_common_commits");
 		get_common_commits();
+		sockstat_bool("cloning", !have_obj.nr);
+		sockstat_string("status", "create_pack_file");
 		create_pack_file();
+	} else {
+		sockstat_string("status", "up_to_date");
+		sockstat_bool("cloning", 0);
 	}
 }
 
@@ -748,6 +764,7 @@ int main(int argc, char **argv)
 		die("attempt to fetch/clone from a shallow repository");
 	if (getenv("GIT_DEBUG_SEND_PACK"))
 		debug_fd = atoi(getenv("GIT_DEBUG_SEND_PACK"));
+	sockstat_init("upload-pack");
 	upload_pack();
 	return 0;
 }
diff --git a/usage.c b/usage.c
index b5e67e3..83fa8bd 100644
--- a/usage.c
+++ b/usage.c
@@ -4,6 +4,7 @@
  * Copyright (C) Linus Torvalds, 2005
  */
 #include "git-compat-util.h"
+#include "sockstat.h"
 
 void vreportf(const char *prefix, const char *err, va_list params)
 {
@@ -65,6 +66,10 @@ void NORETURN die(const char *err, ...)
 	va_list params;
 
 	va_start(params, err);
+	sockstat_valist("fatal", err, params);
+	va_end(params);
+
+	va_start(params, err);
 	die_routine(err, params);
 	va_end(params);
 }
@@ -93,6 +98,10 @@ void NORETURN die_errno(const char *fmt, ...)
 	snprintf(fmt_with_err, sizeof(fmt_with_err), "%s: %s", fmt, str_error);
 
 	va_start(params, fmt);
+	sockstat_valist("fatal", err, params);
+	va_end(params);
+
+	va_start(params, fmt);
 	die_routine(fmt_with_err, params);
 	va_end(params);
 }
@@ -102,6 +111,10 @@ int error(const char *err, ...)
 	va_list params;
 
 	va_start(params, err);
+	sockstat_valist("error", err, params);
+	va_end(params);
+
+	va_start(params, err);
 	error_routine(err, params);
 	va_end(params);
 	return -1;
@@ -112,6 +125,10 @@ void warning(const char *warn, ...)
 	va_list params;
 
 	va_start(params, warn);
+	sockstat_valist("warning", warn, params);
+	va_end(params);
+
+	va_start(params, warn);
 	warn_routine(warn, params);
 	va_end(params);
 }
